/// EVAL script numkeys [key [key ...]] [arg [arg ...]]
pub fn evalCommand(cli: *Client) void {
    server.lua.eval(cli, false);
}

/// EVALSHA sha1 numkeys [key [key ...]] [arg [arg ...]]
pub fn evalShaCommand(cli: *Client) void {
    const argv = cli.argv.?;
    if (sds.getLen(sds.cast(argv[1].v.ptr)) != 40) {
        // We know that a match is not possible if the provided SHA is
        // not the right length. So we return an error ASAP, this way
        // eval() can be implemented without string length sanity check.
        cli.addReply(Server.shared.noscripterr);
        return;
    }
    server.lua.eval(cli, true);
}

/// SCRIPT EXISTS <sha1> [sha1 ...]
///
/// SCRIPT FLUSH
///
/// SCRIPT KILL
///
/// SCRIPT LOAD <script>
///
/// SCRIPT HELP
pub fn scriptCommand(cli: *Client) void {
    const argv = cli.argv.?;

    const opt = sds.castBytes(argv[1].v.ptr);
    if (cli.argc == 2 and eqlCase(opt, "help")) {
        const help: []const []const u8 = &.{
            "EXISTS <sha1> [<sha1> ...] -- Return information about the existence of the scripts in the script cache.",
            "FLUSH -- Flush the Lua scripts cache. Very dangerous on replicas.",
            "KILL -- Kill the currently executing Lua script.",
            "LOAD <script> -- Load a script into the scripts cache, without executing it.",
            "HELP -- Print this help.",
        };
        cli.addReplyHelp(help);
    } else if (cli.argc == 2 and eqlCase(opt, "flush")) {
        server.lua.reset();
        cli.addReply(Server.shared.ok);
        server.dirty +%= 1; // Propagating this command is a good idea.
    } else if (cli.argc >= 2 and eqlCase(opt, "exists")) {
        cli.addReplyMultiBulkLen(@intCast(cli.argc - 2));
        for (2..cli.argc) |i| {
            if (server.lua.scripts.find(sds.cast(argv[i].v.ptr)) != null) {
                cli.addReply(Server.shared.cone);
            } else {
                cli.addReply(Server.shared.czero);
            }
        }
    } else if (cli.argc == 3 and eqlCase(opt, "load")) {
        const sha = server.lua.createFunction(cli, argv[2]) orelse {
            // The error was sent by createFunction().
            return;
        };
        cli.addReplyBulkString(sds.asBytes(sha));
        Server.forceCommandPropagation(
            cli,
            Server.PROPAGATE_AOF | Server.PROPAGATE_REPL,
        );
    } else if (cli.argc == 2 and eqlCase(opt, "kill")) {
        if (server.lua.caller == null) {
            cli.addReplyErr("-NOTBUSY No scripts in execution right now");
        } else if (server.lua.wirte_dirty) {
            cli.addReplyErr("-UNKILLABLE Sorry the script already executed" ++
                " write commands against the dataset. You can either wait " ++
                "the script termination or kill the server in a hard way " ++
                "using the SHUTDOWN NOSAVE command.");
        } else {
            server.lua.kill = true;
            cli.addReply(Server.shared.ok);
        }
    } else {
        cli.addReplySubcommandSyntaxError();
    }
}

pub const Lua = struct {
    const Protocol = struct {
        /// Take a Redis reply in the Redis protocol format and convert it into a
        /// Lua type. Thanks to this function, and the introduction of not connected
        /// clients, it is trivial to implement the redis() lua function.
        ///
        /// Basically we take the arguments, execute the Redis command in the context
        /// of a non connected client, then take the generated reply and convert it
        /// into a suitable Lua type. With this trick the scripting feature does not
        /// need the introduction of a full Redis internals API. The script
        /// is like a normal client that bypasses all the slow I/O paths.
        ///
        /// Note: in this function we do not do any sanity check as the reply is
        /// generated by Redis directly. This allows us to go faster.
        ///
        /// Errors are returned as a table with a single 'err' field set to the
        /// error string.
        fn toLuaType(reply: [:0]u8, lua: *Lua) [:0]u8 {
            if (lua_checkstack(lua.state, 5) == 0) {
                // Increase the Lua stack if needed, to make sure there is enough
                // room to push 5 elements to the stack. On failure, exit with panic.
                // Notice that we need, in the worst case, 5 elements because
                // toLuaType_MultiBulk might push 5 elements to the Lua stack.
                @panic("lua stack limit reach when parsing redis.call reply");
            }
            return switch (reply[0]) {
                ':' => toLuaType_Int(reply, lua),
                '$' => toLuaType_Bulk(reply, lua),
                '+' => toLuaType_Status(reply, lua),
                '-' => toLuaType_Error(reply, lua),
                '*' => toLuaType_MultiBulk(reply, lua),
                else => reply,
            };
        }

        fn toLuaType_Int(reply: [:0]u8, lua: *Lua) [:0]u8 {
            const i = std.mem.indexOfScalar(u8, reply, '\r').?;
            const value = util.string2ll(reply[1..i]).?;
            lua_pushnumber(lua.state, @floatFromInt(value));
            return reply[i + 2 .. :0];
        }

        fn toLuaType_Bulk(reply: [:0]u8, lua: *Lua) [:0]u8 {
            const i = std.mem.indexOfScalar(u8, reply, '\r').?;
            const bulklen = util.string2ll(reply[1..i]).?;
            if (bulklen == -1) {
                lua_pushboolean(lua.state, 0);
                return reply[i + 2 .. :0];
            }
            const len: usize = @intCast(bulklen);
            lua_pushlstring(lua.state, reply[i + 2 ..], len);
            return reply[i + 2 + len + 2 .. :0];
        }

        fn toLuaType_Status(reply: [:0]u8, lua: *Lua) [:0]u8 {
            const i = std.mem.indexOfScalar(u8, reply, '\r').?;
            const status = reply[1..i];
            lua_newtable(lua.state);
            lua_pushstring(lua.state, "ok");
            lua_pushlstring(lua.state, status.ptr, status.len);
            lua_settable(lua.state, -3);
            return reply[i + 2 .. :0];
        }

        fn toLuaType_Error(reply: [:0]u8, lua: *Lua) [:0]u8 {
            const i = std.mem.indexOfScalar(u8, reply, '\r').?;
            const err = reply[1..i];
            lua_newtable(lua.state);
            lua_pushstring(lua.state, "err");
            lua_pushlstring(lua.state, err.ptr, err.len);
            lua_settable(lua.state, -3);
            return reply[i + 2 .. :0];
        }

        fn toLuaType_MultiBulk(reply: [:0]u8, lua: *Lua) [:0]u8 {
            var rep = reply;
            const i = std.mem.indexOfScalar(u8, rep, '\r').?;
            const mbulklen = util.string2ll(rep[1..i]).?;
            rep = rep[i + 2 .. :0];
            if (mbulklen == -1) {
                lua_pushboolean(lua.state, 0);
                return rep;
            }
            lua_newtable(lua.state);
            for (0..@as(usize, @intCast(mbulklen))) |j| {
                lua_pushnumber(lua.state, @floatFromInt(j + 1));
                rep = toLuaType(rep, lua);
                lua_settable(lua.state, -3);
            }
            return rep;
        }
    };

    const Redis = struct {
        /// redis.call()
        fn call(_: ?*lua_State) callconv(.c) c_int {
            return gcall(&server.lua, false);
        }

        /// redis.pcall()
        fn pcall(_: ?*lua_State) callconv(.c) c_int {
            return gcall(&server.lua, true);
        }

        fn gcall(lua: *Lua, protected: bool) c_int {
            // TODO: server.loading

            var raise_error = protected;
            // Cached across calls.
            const Cached = struct {
                const OBJCACHE_SIZE = 32;
                const OBJCACHE_MAX_LEN = 64;

                var argv: ?[]*Object = null;
                var argc: usize = 0;
                var objects: [OBJCACHE_SIZE]?*Object = @splat(null);
                var objects_len: [OBJCACHE_SIZE]usize = @splat(0);
            };

            const argc: usize = @intCast(lua_gettop(lua.state));
            const cli = lua.client.?;

            // Require at least one argument
            if (argc == 0) {
                lua.pushError("Please specify at least one argument for redis.call()");
                return if (raise_error) lua.raiseError() else 1;
            }

            // Build the arguments vector
            if (Cached.argc < argc) {
                if (Cached.argv) |argv| {
                    Cached.argv = allocator.realloc(argv, argc);
                } else {
                    Cached.argv = allocator.alloc(*Object, argc);
                }
                Cached.argc = argc;
            }

            var j: usize = 0;
            while (j < argc) : (j += 1) {
                var dbuf: [64]u8 = undefined;
                var args: []const u8 = undefined;

                const idx: c_int = @intCast(j + 1);
                if (lua_type(lua.state, idx) == LUA_TNUMBER) {
                    const num = lua_tonumber(lua.state, idx);
                    args = util.d2string(&dbuf, num);
                } else {
                    var len: usize = undefined;
                    const s = lua_tolstring(lua.state, idx, &len);
                    if (s == null) break; // Not a string.
                    args = s[0..len];
                }

                // Try to use a cached object.
                if (j < Cached.OBJCACHE_SIZE and
                    Cached.objects[j] != null and
                    Cached.objects_len[j] >= args.len)
                {
                    const obj = Cached.objects[j].?;
                    Cached.argv.?[j] = obj;
                    const s = sds.cast(obj.v.ptr);
                    Cached.objects[j] = null;
                    memcpy(s, args, args.len);
                    s[args.len] = 0;
                    sds.setLength(s, args.len);
                } else {
                    Cached.argv.?[j] = Object.createString(args);
                }
            }

            // Check if one of the arguments passed by the Lua script
            // is not a string or an integer (lua_isstring() return true for
            // integers as well).
            if (j != argc) {
                var i: i64 = @intCast(j);
                i -= 1;
                while (i >= 0) : (i -= 1) {
                    Cached.argv.?[@intCast(i)].decrRefCount();
                }
                lua.pushError("Lua redis() command arguments must be strings or integers");
                return if (raise_error) lua.raiseError() else 1;
            }

            // Setup our fake client for command execution
            cli.argc = argc;
            cli.argv = Cached.argv;

            biz: {
                // Command lookup
                const cmd = server.lookupCommand(sds.cast(Cached.argv.?[0].v.ptr));
                if (cmd == null or
                    (cmd.?.arity > 0 and cmd.?.arity != argc) or
                    (argc < -cmd.?.arity))
                {
                    if (cmd != null) {
                        lua.pushError("Wrong number of args calling Redis command From Lua script");
                    } else {
                        lua.pushError("Unknown Redis command called from Lua script");
                    }
                    break :biz;
                }
                cli.cmd = cmd;
                cli.lastcmd = cmd;

                // There are commands that are not allowed inside scripts.
                if (cmd.?.flags & Server.CMD_NOSCRIPT != 0) {
                    lua.pushError("This Redis command is not allowed from scripts");
                    break :biz;
                }

                if (cmd.?.flags & Server.CMD_RANDOM != 0) {
                    lua.random_dirty = true;
                }
                if (cmd.?.flags & Server.CMD_WRITE != 0) {
                    lua.wirte_dirty = true;
                }

                // Run the command
                // TODO: more flags
                const call_flags = Server.CMD_CALL_SLOWLOG | Server.CMD_CALL_STATS;
                server.call(cli, call_flags);

                var reply: [:0]u8 = undefined;
                // Convert the result of the Redis command into a suitable Lua type.
                // The first thing we need is to create a single string from the client
                // output buffers.
                if (cli.reply.len == 0 and cli.bufpos < Server.PROTO_REPLY_CHUNK_BYTES) {
                    // This is a fast path for the common case of a reply inside the
                    // client static buffer. Don't create an SDS string but just use
                    // the client buffer directly.
                    cli.buf[cli.bufpos] = 0;
                    reply = cli.buf[0..cli.bufpos :0];
                    cli.bufpos = 0;
                } else {
                    var s = sds.new(allocator.impl, cli.buf[0..cli.bufpos]);
                    while (cli.reply.len != 0) {
                        const node = cli.reply.first.?;
                        const rb = node.value;
                        s = sds.cat(allocator.impl, s, rb.slice(0, rb.used));
                        cli.reply.removeNode(node);
                    }
                    cli.bufpos = 0;
                    cli.reply_bytes = 0;
                    reply = sds.asSentinelBytes(s);
                }
                if (raise_error and reply[0] != '-') {
                    raise_error = false;
                }
                _ = Protocol.toLuaType(reply, lua);

                // Sort the output array if needed, assuming it is a non-null multi bulk
                // reply as expected.
                if (cmd.?.flags & Server.CMD_SORT_FOR_SCRIPT != 0 and
                    (reply[0] == '*' and reply[1] != '-'))
                {
                    lua.sortArray();
                }
                if (@intFromPtr(reply.ptr) != @intFromPtr(&cli.buf)) {
                    sds.free(allocator.impl, @ptrCast(reply));
                }
            }

            // Clean up. Command code may have changed argv/argc so we use the
            // argv/argc of the client instead of the local variables.
            for (0..cli.argc) |i| {
                const o = cli.argv.?[i];
                // Try to cache the object in the cached_objects array.
                // The object must be small, SDS-encoded, and with refcount = 1
                // (we must be the only owner) for us to cache it.
                if (i < Cached.OBJCACHE_SIZE and
                    o.refcount == 1 and
                    (o.encoding == .raw or o.encoding == .embstr) and
                    sds.getLen(sds.cast(o.v.ptr)) <= Cached.OBJCACHE_MAX_LEN)
                {
                    const s = sds.cast(o.v.ptr);
                    if (Cached.objects[i]) |co| {
                        co.decrRefCount();
                    }
                    Cached.objects[i] = o;
                    Cached.objects_len[i] = sds.getAlloc(s);
                } else {
                    o.decrRefCount();
                }
            }
            if (!std.meta.eql(cli.argv, Cached.argv)) {
                allocator.free(cli.argv.?);
                Cached.argv = null;
                Cached.argc = 0;
            }
            if (raise_error) {
                // If we are here we should have an error in the stack, in the
                // form of a table with an "err" field. Extract the string to
                // return the plain error.
                return lua.raiseError();
            }
            return 1;
        }

        /// redis.log()
        fn log(lua: ?*lua_State) callconv(.c) c_int {
            const argc = lua_gettop(lua);
            if (argc < 2) {
                lua_pushstring(
                    lua,
                    "redis.log() requires two arguments or more.",
                );
                return lua_error(lua);
            } else if (lua_isnumber(lua, -argc) != 1) {
                lua_pushstring(
                    lua,
                    "First argument must be a number (log level).",
                );
                return lua_error(lua);
            }

            const level: c_int = @intFromFloat(lua_tonumber(lua, -argc));
            if (level < logging.DEBUG or level > logging.WARNING) {
                lua_pushstring(lua, "Invalid debug level.");
                return lua_error(lua);
            }

            // Glue together all the arguments
            var msg = sds.empty(allocator.impl);
            defer sds.free(allocator.impl, msg);
            for (2..@as(usize, @intCast(argc + 1))) |i| {
                var len: usize = undefined;
                const s = lua_tolstring(lua, @intCast(i), &len);
                if (s != null) {
                    if (i != 2) {
                        msg = sds.cat(allocator.impl, msg, " ");
                    }
                    msg = sds.cat(allocator.impl, msg, s[0..len]);
                }
            }
            logging.raw(@intCast(level), "{s}", .{sds.asBytes(msg)});
            return 0;
        }

        /// This adds redis.sha1hex(string) to Lua scripts using the same hashing
        /// function used for sha1ing lua scripts.
        fn sha1hex(lua: ?*lua_State) callconv(.c) c_int {
            const argc = lua_gettop(lua);
            if (argc != 1) {
                lua_pushstring(lua, "wrong number of arguments");
                return lua_error(lua);
            }
            var len: usize = undefined;
            const s = lua_tolstring(lua, 1, &len);
            var digest: [40:0]u8 = undefined;
            digest[40] = 0;
            scripting.sha1hex(&digest, s[0..len]);
            lua_pushstring(lua, &digest);
            return 1;
        }

        /// redis.error_reply()
        fn errorReply(_: ?*lua_State) callconv(.c) c_int {
            return returnSingleFieldTable(&server.lua, "err");
        }

        /// redis.status_reply()
        fn statusReply(_: ?*lua_State) callconv(.c) c_int {
            return returnSingleFieldTable(&server.lua, "ok");
        }

        /// Returns a table with a single field 'field' set to the string value
        /// passed as argument. This helper function is handy when returning
        /// a Redis Protocol error or status reply from Lua:
        ///
        /// return redis.error_reply("ERR Some Error")
        /// return redis.status_reply("ERR Some Error")
        fn returnSingleFieldTable(
            lua: *Lua,
            comptime field: [:0]const u8,
        ) c_int {
            if (lua_gettop(lua.state) != 1 or lua_type(lua.state, -1) != LUA_TSTRING) {
                lua.pushError("wrong number or type of arguments");
                return 1;
            }
            lua_newtable(lua.state);
            lua_pushstring(lua.state, field);
            lua_pushvalue(lua.state, -3);
            lua_settable(lua.state, -3);
            return 1;
        }
    };

    const Rand = struct {
        var prng: std.Random.DefaultPrng = .init(0);
        var random: std.Random = prng.random();

        fn seed(s: u64) void {
            prng = .init(s);
            random = prng.random();
        }

        fn intRangeAtMost(comptime T: type, at_least: T, at_most: T) T {
            return random.intRangeAtMost(T, at_least, at_most);
        }
    };

    /// We replace math.random() with our implementation that is not affected
    /// by specific libc random() implementations and will output the same
    /// sequence (for the same seed) in every arch.
    ///
    /// The following implementation is the one shipped with Lua itself but
    /// with rand() replaced by Rand.
    const Math = struct {
        fn random(lua: ?*lua_State) callconv(.c) c_int {
            switch (lua_gettop(lua)) {
                // no arguments
                0 => {
                    const r = Rand.intRangeAtMost(lua_Integer, 0, 1);
                    lua_pushnumber(lua, @floatFromInt(r)); // 0 - 1
                },
                // only upper limit
                1 => {
                    const upper = luaL_checkinteger(lua, 1);
                    luaL_argcheck(
                        lua,
                        1 <= upper,
                        1,
                        "interval is empty",
                    );
                    const r = Rand.intRangeAtMost(lua_Integer, 1, upper);
                    lua_pushnumber(lua, @floatFromInt(r)); // 1 - upper
                },
                // lower and upper limits
                2 => {
                    const lower = luaL_checkinteger(lua, 1);
                    const upper = luaL_checkinteger(lua, 2);
                    luaL_argcheck(
                        lua,
                        lower <= upper,
                        2,
                        "interval is empty",
                    );
                    const r = Rand.intRangeAtMost(lua_Integer, lower, upper);
                    lua_pushnumber(lua, @floatFromInt(r)); // lower - upper
                },
                else => {
                    return luaL_error(lua, "wrong number of arguments");
                },
            }
            return 1;
        }

        fn randomseed(lua: ?*lua_State) callconv(.c) c_int {
            const seed = luaL_checkinteger(lua, 1);
            Rand.seed(@bitCast(seed));
            return 0;
        }
    };

    const Scripts = struct {
        const HashMap = dict.Dict(sds.String, *Object);

        fn keyHash(key: sds.String) hasher.Hash {
            return hasher.hashcase(sds.asBytes(key), 64);
        }

        fn freeKey(key: sds.String) void {
            sds.free(allocator.impl, key);
        }
    };

    const Gc = struct {
        const CYCLE_PERIOD = 50;
        var count: usize = 0;

        /// The call is performed every Gc.CYCLE_PERIOD executed commands
        /// (and for Gc.CYCLE_PERIOD collection steps) because calling it
        /// for every command uses too much CPU.
        fn step(lua: *Lua) void {
            count += 1;
            if (count == CYCLE_PERIOD) {
                _ = lua_gc(lua.state, LUA_GCSTEP, CYCLE_PERIOD);
                count = 0;
            }
        }
    };

    state: ?*lua_State,
    /// The "fake client" to query Redis from Lua
    client: ?*Client,
    /// The client running EVAL right now, or NULL
    caller: ?*Client,
    /// A dictionary of SHA1 -> Lua scripts
    scripts: *Scripts.HashMap,
    /// Script timeout in milliseconds
    time_limit: i64,
    /// Start time of script, milliseconds time
    time_start: i64,
    /// True if a write command was called during the
    /// execution of the current script.
    wirte_dirty: bool,
    /// True if a random command was called during the
    /// execution of the current script.
    random_dirty: bool,
    /// True if we reached the time limit for script execution.
    timeout: bool,
    /// Kill the script if true.
    kill: bool,

    /// Initialize the scripting environment.
    pub fn init(self: *Lua, setup: bool) void {
        const lua = lua_open(); // TODO: lua_newstate
        self.state = lua;

        if (setup) {
            self.client = null;
            self.caller = null;
            self.timeout = false;
        }

        self.loadLibraries();
        self.removeUnsupportedFunctions();

        // Initialize a dictionary we use to map SHAs to scripts.
        // This is useful for replication, as we need to replicate EVALSHA
        // as EVAL, so we need to remember the associated script.
        self.scripts = .create(&.{
            .hash = Scripts.keyHash,
            .eql = sds.eqlCase,
            .freeKey = Scripts.freeKey,
            .dupeVal = Object.incrRefCount,
            .freeVal = Object.decrRefCount,
        });

        // Register the redis commands table and fields
        lua_newtable(lua);

        // redis.call
        lua_pushstring(lua, "call");
        lua_pushcfunction(lua, Redis.call);
        lua_settable(lua, -3);

        // redis.pcall
        lua_pushstring(lua, "pcall");
        lua_pushcfunction(lua, Redis.pcall);
        lua_settable(lua, -3);

        // redis.log and log levels.
        lua_pushstring(lua, "log");
        lua_pushcfunction(lua, Redis.log);
        lua_settable(lua, -3);

        lua_pushstring(lua, "LOG_DEBUG");
        lua_pushnumber(lua, logging.DEBUG);
        lua_settable(lua, -3);

        lua_pushstring(lua, "LOG_VERBOSE");
        lua_pushnumber(lua, logging.VERBOSE);
        lua_settable(lua, -3);

        lua_pushstring(lua, "LOG_NOTICE");
        lua_pushnumber(lua, logging.NOTICE);
        lua_settable(lua, -3);

        lua_pushstring(lua, "LOG_WARNING");
        lua_pushnumber(lua, logging.WARNING);
        lua_settable(lua, -3);

        // redis.sha1hex
        lua_pushstring(lua, "sha1hex");
        lua_pushcfunction(lua, Redis.sha1hex);
        lua_settable(lua, -3);

        // redis.error_reply and redis.status_reply
        lua_pushstring(lua, "error_reply");
        lua_pushcfunction(lua, Redis.errorReply);
        lua_settable(lua, -3);

        lua_pushstring(lua, "status_reply");
        lua_pushcfunction(lua, Redis.statusReply);
        lua_settable(lua, -3);

        // Finally set the table as 'redis' global var.
        lua_setglobal(lua, "redis");

        // Replace math.random and math.randomseed with our implementations.
        lua_getglobal(lua, "math");

        lua_pushstring(lua, "random");
        lua_pushcfunction(lua, Math.random);
        lua_settable(lua, -3);

        lua_pushstring(lua, "randomseed");
        lua_pushcfunction(lua, Math.randomseed);
        lua_settable(lua, -3);

        lua_setglobal(lua, "math");

        // Add a helper function that we use to sort the multi bulk output of non
        // deterministic commands, when containing 'false' elements.
        // zig fmt: off
        const compare_func: []const u8 =
            "function __redis__compare_helper(a,b)\n" ++
            "  if a == false then a = '' end\n" ++
            "  if b == false then b = '' end\n" ++
            "  return a<b\n" ++
            "end\n";
        // zig fmt: on
        _ = luaL_loadbuffer(
            lua,
            compare_func.ptr,
            compare_func.len,
            "@cmp_func_def",
        );
        _ = lua_pcall(lua, 0, 0, 0);

        // Add a helper function we use for pcall error reporting.
        // Note that when the error is in the C function we want to report the
        // information about the caller, that's what makes sense from the point
        // of view of the user debugging a script.
        // zig fmt: off
        const errh_func: []const u8 =
            "local dbg = debug\n" ++
            "function __redis__err__handler(err)\n" ++
            "  local i = dbg.getinfo(2,'nSl')\n" ++
            "  if i and i.what == 'C' then\n" ++
            "    i = dbg.getinfo(3,'nSl')\n" ++
            "  end\n" ++
            "  if i then\n" ++
            "    return i.source .. ':' .. i.currentline .. ': ' .. err\n" ++
            "  else\n" ++
            "    return err\n" ++
            "  end\n" ++
            "end\n";
        // zig fmt: on
        _ = luaL_loadbuffer(
            lua,
            errh_func.ptr,
            errh_func.len,
            "@err_handler_def",
        );
        _ = lua_pcall(lua, 0, 0, 0);

        // Create the (non connected) client that we use to execute Redis commands
        // inside the Lua interpreter.
        // Note: there is no need to create it again when this function is called
        // by reset().
        if (self.client == null) {
            self.client = Client.create(-1, Server.CLIENT_LUA) catch {
                unreachable;
            };
        }

        // Lua beginners often don't use "local", this is likely to introduce
        // subtle bugs in their code. To prevent problems we protect accesses
        // to global variables.
        self.enableGlobalsProtection();
    }

    fn loadLibraries(self: *Lua) void {
        self.loadLib("", luaopen_base);
        self.loadLib(LUA_TABLIBNAME, luaopen_table);
        self.loadLib(LUA_STRLIBNAME, luaopen_string);
        self.loadLib(LUA_MATHLIBNAME, luaopen_math);
        self.loadLib(LUA_DBLIBNAME, luaopen_debug);
        self.loadLib("cjson", luaopen_cjson);
        self.loadLib("struct", luaopen_struct);
        self.loadLib("cmsgpack", luaopen_cmsgpack);
        self.loadLib("bit", luaopen_bit);
    }

    fn loadLib(self: *Lua, name: [*c]const u8, func: lua_CFunction) void {
        lua_pushcfunction(self.state, func);
        lua_pushstring(self.state, name);
        lua_call(self.state, 1, 0);
    }

    /// Remove a functions that we don't want to expose to the Redis scripting
    /// environment.
    fn removeUnsupportedFunctions(self: *Lua) void {
        lua_pushnil(self.state);
        lua_setglobal(self.state, "loadfile");
        lua_pushnil(self.state);
        lua_setglobal(self.state, "dofile");
    }

    /// This function installs metamethods in the global table _G that prevent
    /// the creation of globals accidentally.
    ///
    /// It should be the last to be called in the scripting engine initialization
    /// sequence, because it may interact with creation of globals.
    fn enableGlobalsProtection(self: *Lua) void {
        const s: []const u8 =
            \\local dbg=debug
            \\local mt = {}
            \\setmetatable(_G, mt)
            \\mt.__newindex = function (t, n, v)
            \\  if dbg.getinfo(2) then
            \\    local w = dbg.getinfo(2, "S").what
            \\    if w ~= "main" and w ~= "C" then
            \\      error("Script attempted to create global variable '"..tostring(n).."'", 2)
            \\    end
            \\  end
            \\  rawset(t, n, v)
            \\end
            \\mt.__index = function (t, n)
            \\  if dbg.getinfo(2) and dbg.getinfo(2, "S").what ~= "C" then
            \\    error("Script attempted to access nonexistent global variable '"..tostring(n).."'", 2)
            \\  end
            \\  return rawget(t, n)
            \\end
            \\debug = nil
        ;
        var err = luaL_loadbuffer(
            self.state,
            s.ptr,
            s.len,
            "@enable_strict_lua",
        );
        assert(err == 0);
        err = lua_pcall(self.state, 0, 0, 0);
        assert(err == 0);
    }

    fn eval(self: *Lua, cli: *Client, evalsha: bool) void {
        const argv = cli.argv.?;

        // When we replicate whole scripts, we want the same PRNG sequence at
        // every call so that our PRNG is not affected by external state.
        Rand.seed(0);

        // We set this flag to zero to remember that so far no random command
        // was called. This way we can allow the user to call commands like
        // SRANDMEMBER or RANDOMKEY from Lua scripts as far as no write command
        // is called (otherwise the replication and AOF would end with non
        // deterministic sequences).
        //
        // Thanks to this flag we'll raise an error every time a write command
        // is called after a random command was used.
        self.random_dirty = false;
        self.wirte_dirty = false;

        // Get the number of arguments that are keys
        const numkeys = argv[2].getLongLongOrReply(cli, null) orelse {
            return;
        };
        if (numkeys > (cli.argc - 3)) {
            cli.addReplyErr("Number of keys can't be greater than number of args");
            return;
        } else if (numkeys < 0) {
            cli.addReplyErr("Number of keys can't be negative");
            return;
        }

        // We obtain the script SHA1, then check if this function is already
        // defined into the Lua state
        var funcname: [42:0]u8 = undefined;
        funcname[0] = 'f';
        funcname[1] = '_';
        funcname[42] = 0;
        if (!evalsha) {
            // Hash the code if this is an EVAL call
            sha1hex(funcname[2..], sds.castBytes(argv[1].v.ptr));
        } else {
            // We already have the SHA if it is a EVALSHA
            const sha = sds.castBytes(argv[1].v.ptr);
            for (0..40) |i| {
                funcname[i + 2] = if (sha[i] >= 'A' and sha[i] <= 'Z')
                    sha[i] + ('a' - 'A')
                else
                    sha[i];
            }
        }

        // Push the pcall error handler function on the stack.
        lua_getglobal(self.state, "__redis__err__handler");
        // Try to lookup the Lua function
        lua_getglobal(self.state, &funcname);
        if (lua_isnil(self.state, -1)) {
            // remove the nil from the stack
            lua_pop(self.state, 1);
            // Function not defined... let's define it if we have the
            // body of the function. If this is an EVALSHA call we can just
            // return an error.
            if (evalsha) {
                // remove the error handler from the stack.
                lua_pop(self.state, 1);
                cli.addReply(Server.shared.noscripterr);
                return;
            }
            if (self.createFunction(cli, argv[1]) == null) {
                // remove the error handler from the stack.
                lua_pop(self.state, 1);
                // The error is sent to the client by createFunction()
                // itself when it returns NULL.
                return;
            }
            // Now the following is guaranteed to return non nil
            lua_getglobal(self.state, &funcname);
            assert(!lua_isnil(self.state, -1));
        }
        // Populate the argv and keys table accordingly to the arguments that
        // EVAL received.
        self.setGlobalArray(
            "KEYS",
            argv[3 .. 3 + @as(usize, @intCast(numkeys))],
        );
        self.setGlobalArray(
            "ARGV",
            argv[3 + @as(usize, @intCast(numkeys)) .. cli.argc],
        );

        // Select the right DB in the context of the Lua client
        assert(db.select(self.client.?, @intCast(cli.db.id)));

        // Set a hook in order to be able to stop the script execution if it
        // is running for too much time.
        // We set the hook only if the time limit is enabled as the hook will
        // make the Lua script execution slower.
        self.caller = cli;
        self.time_start = std.time.milliTimestamp();
        self.kill = false;
        var delhook = false;
        if (self.time_limit > 0) {
            _ = lua_sethook(
                self.state,
                maskCountHook,
                LUA_MASKCOUNT,
                100000,
            );
            delhook = true;
        }

        // At this point whether this script was never seen before or if it was
        // already defined, we can call it. We have zero arguments and expect
        // a single return value.
        const err = lua_pcall(self.state, 0, 1, -2);

        // Perform some cleanup that we need to do both on error and success.
        if (delhook) {
            // Disable hook
            _ = lua_sethook(self.state, null, 0, 0);
        }
        if (self.timeout) {
            self.timeout = false;
            // Restore the client that was protected when the script timeout
            // was detected.
            cli.unprotect() catch {};
        }
        self.caller = null;

        // Call the Lua garbage collector from time to time to avoid a
        // full cycle performed by Lua, which adds too latency.
        Gc.step(self);

        if (err != 0) {
            cli.addReplyErrFormat(
                "Error running script (call to {s}): {s}\n",
                .{
                    &funcname,
                    lua_tolstring(self.state, -1, null),
                },
            );
            // Consume the Lua reply and remove error handler.
            lua_pop(self.state, 2);
        } else {
            // On success convert the Lua return value into Redis protocol, and
            // send it to * the client.
            self.toRedisReply(cli); // Convert and consume the reply.
            lua_pop(self.state, 1); // Remove the error handler.
        }
    }

    /// Set an array of Redis String Objects as a Lua array (table) stored into a
    // global variable.
    fn setGlobalArray(self: *Lua, name: [:0]const u8, elements: []*Object) void {
        lua_newtable(self.state);
        for (elements, 0..) |ele, i| {
            lua_pushstring(
                self.state,
                sds.asSentinelBytes(sds.cast(ele.v.ptr)),
            );
            lua_rawseti(self.state, -2, @intCast(i + 1));
        }
        lua_setglobal(self.state, name);
    }

    /// This is the Lua script "count" hook that we use to detect
    /// scripts timeout.
    fn maskCountHook(lua: ?*lua_State, ar: [*c]lua_Debug) callconv(.c) void {
        _ = ar;
        const elapsed = std.time.milliTimestamp() - server.lua.time_start;

        // Set the timeout condition if not already set and the maximum
        // execution time was reached.
        if (elapsed >= server.lua.time_limit and !server.lua.timeout) {
            logging.warn(
                "Lua slow script detected: still in execution after" ++
                    "{} milliseconds. You can try killing the script using" ++
                    "the SCRIPT KILL command.",
                .{elapsed},
            );
            server.lua.timeout = true;
            // Once the script timeouts we reenter the event loop to permit others
            // to call SCRIPT KILL or SHUTDOWN NOSAVE if needed. For this reason
            // we need to mask the client executing the script from the event loop.
            // If we don't do that the client may disconnect and could no longer be
            // here when the EVAL command will return.
            server.lua.caller.?.protect() catch {};
        }
        if (server.lua.timeout) {
            _ = networking.processEventsWhileBlocked() catch {};
        }
        if (server.lua.kill) {
            logging.warn("Lua script killed by user with SCRIPT KILL.", .{});
            lua_pushstring(
                lua,
                "Script killed by user with SCRIPT KILL...",
            );
            _ = lua_error(lua);
        }
    }

    fn toRedisReply(self: *Lua, cli: *Client) void {
        if (lua_checkstack(self.state, 4) == 0) {
            // Increase the Lua stack if needed to make sure there is enough room
            // to push 4 elements to the stack. On failure, return error.
            // Notice that we need, in the worst case, 4 elements because returning a map might
            // require push 4 elements to the Lua stack.
            cli.addReplyErrFormat("reached lua stack limit", .{});
            lua_pop(self.state, 1); // pop the element from the stack
            return;
        }
        var len: usize = undefined;
        switch (lua_type(self.state, -1)) {
            LUA_TSTRING => {
                const s = lua_tolstring(self.state, -1, &len);
                cli.addReplyBulkString(s[0..len]);
            },
            LUA_TBOOLEAN => {
                const v = lua_toboolean(self.state, -1) == 1;
                cli.addReply(
                    if (v)
                        Server.shared.cone
                    else
                        Server.shared.nullbulk,
                );
            },
            LUA_TNUMBER => {
                const v = lua_tonumber(self.state, -1);
                cli.addReplyLongLong(@intFromFloat(v));
            },
            LUA_TTABLE => {
                // We need to check if it is an array, an error, or a status reply.
                // Error are returned as a single element table with 'err' field.
                // Status replies are returned as single element table with 'ok'
                // field.

                // Handle error reply.
                // we took care of the stack size on function start
                lua_pushstring(self.state, "err");
                lua_gettable(self.state, -2);
                if (lua_type(self.state, -1) == LUA_TSTRING) {
                    const s = lua_tolstring(self.state, -1, &len);
                    const err = sds.new(allocator.impl, s[0..len]);
                    defer sds.free(allocator.impl, err);
                    _ = sds.mapChars(err, "\r\n", "  ");
                    cli.addReplyErr(sds.asBytes(err));
                    lua_pop(self.state, 2);
                    return;
                }

                lua_pop(self.state, 1);
                lua_pushstring(self.state, "ok");
                lua_gettable(self.state, -2);
                if (lua_type(self.state, -1) == LUA_TSTRING) {
                    const s = lua_tolstring(self.state, -1, &len);
                    const ok = sds.new(allocator.impl, s[0..len]);
                    defer sds.free(allocator.impl, ok);
                    _ = sds.mapChars(ok, "\r\n", "  ");
                    cli.addReplyBulkString(sds.asBytes(ok));
                    lua_pop(self.state, 1);
                } else {
                    const replylen = cli.addDeferredMultiBulkLength();
                    // Discard the 'ok' field value we popped
                    lua_pop(self.state, 1);
                    var mbulklen: i64 = 0;
                    var i: usize = 1;
                    while (true) : (i += 1) {
                        // we took care of the stack size on function start
                        lua_pushnumber(self.state, @floatFromInt(i));
                        lua_gettable(self.state, -2);
                        if (lua_type(self.state, -1) == LUA_TNIL) {
                            lua_pop(self.state, 1);
                            break;
                        }
                        self.toRedisReply(cli);
                        mbulklen += 1;
                    }
                    cli.setDeferredMultiBulkLength(replylen, mbulklen);
                }
            },
            else => {
                cli.addReply(Server.shared.nullbulk);
            },
        }
        lua_pop(self.state, 1);
    }

    /// Define a Lua function with the specified body.
    /// The function name will be generated in the following form:
    ///
    ///   f_<hex sha1 sum>
    ///
    /// The function increments the reference count of the 'body' object as a
    /// side effect of a successful call.
    ///
    /// On success a pointer to an SDS string representing the function SHA1 of the
    /// just added function is returned (and will be valid until the next call
    /// to reset() function), otherwise NULL is returned.
    ///
    /// The function handles the fact of being called with a script that already
    /// exists, and in such a case, it behaves like in the success case.
    ///
    /// If 'cli' is not NULL, on error the client is informed with an appropriate
    /// error describing the nature of the problem and the Lua interpreter error.
    pub fn createFunction(self: *Lua, cli: ?*Client, body: *Object) ?sds.String {
        var funcname: [42:0]u8 = undefined;
        funcname[0] = 'f';
        funcname[1] = '_';
        funcname[42] = 0;
        const script = sds.castBytes(body.v.ptr);
        sha1hex(funcname[2..], script);

        const sha = sds.new(allocator.impl, funcname[2..]);
        if (self.scripts.find(sha)) |de| {
            sds.free(allocator.impl, sha);
            return de.key;
        }

        var funcdef = sds.empty(allocator.impl);
        defer sds.free(allocator.impl, funcdef);
        funcdef = sds.cat(allocator.impl, funcdef, "function ");
        funcdef = sds.cat(allocator.impl, funcdef, funcname[0..]);
        funcdef = sds.cat(allocator.impl, funcdef, "() ");
        funcdef = sds.cat(allocator.impl, funcdef, script);
        funcdef = sds.cat(allocator.impl, funcdef, "\nend");

        if (luaL_loadbuffer(
            self.state,
            funcdef,
            sds.getLen(funcdef),
            "@user_script",
        ) != 0) {
            if (cli) |c| {
                c.addReplyErrFormat(
                    "Error compiling script (new function): {s}\n",
                    .{
                        lua_tolstring(self.state, -1, null),
                    },
                );
            }
            lua_pop(self.state, 1);
            sds.free(allocator.impl, sha);
            return null;
        }

        if (lua_pcall(self.state, 0, 0, 0) != 0) {
            if (cli) |c| {
                c.addReplyErrFormat(
                    "Error running script (new function): {s}\n",
                    .{
                        lua_tolstring(self.state, -1, null),
                    },
                );
            }
            lua_pop(self.state, 1);
            sds.free(allocator.impl, sha);
            return null;
        }

        // We also save a SHA1 -> Original script map in a dictionary
        // so that we can replicate / write in the AOF all the
        // EVALSHA commands as EVAL using the original script.
        assert(self.scripts.add(sha, body));
        return sha;
    }

    /// Sort the array currently in the stack. We do this to make the output
    /// of commands like KEYS or SMEMBERS something deterministic when called
    /// from Lua (to play well with AOf/replication).
    ///
    /// The array is sorted using table.sort itself, and assuming all the
    /// list elements are strings.
    fn sortArray(self: *Lua) void {
        // Initial Stack: array
        lua_getglobal(self.state, "table");
        lua_pushstring(self.state, "sort");
        lua_gettable(self.state, -2); // Stack: array, table, table.sort
        lua_pushvalue(self.state, -3); // Stack: array, table, table.sort, array
        if (lua_pcall(self.state, 1, 0, 0) != 0) {
            // Stack: array, table, error

            // We are not interested in the error, we assume that the problem is
            // that there are 'false' elements inside the array, so we try
            // again with a slower function but able to handle this case, that
            // is: table.sort(table, __redis__compare_helper)
            lua_pop(self.state, 1); // Stack: array, table
            lua_pushstring(self.state, "sort"); // Stack: array, table, sort
            lua_gettable(self.state, -2); // Stack: array, table, table.sort
            lua_pushvalue(self.state, -3); // Stack: array, table, table.sort, array
            lua_getglobal(self.state, "__redis__compare_helper");
            // Stack: array, table, table.sort, array, __redis__compare_helper
            lua_call(self.state, 2, 0);
        }
        // Stack: array(sorted), table
        lua_pop(self.state, 1); // Stack: array (sorted)
    }

    /// This function is used in order to push an error on the Lua stack in the
    /// format used by redis.pcall to return errors, which is a lua table
    /// with a single "err" field set to the error string. Note that this
    /// table is never a valid reply by proper commands, since the returned
    /// tables are otherwise always indexed by integers, never by strings.
    fn pushError(self: *Lua, err: [:0]const u8) void {
        var dbg: lua_Debug = undefined;
        lua_newtable(self.state);
        lua_pushstring(self.state, "err");
        // Attempt to figure out where this function was called, if possible
        if (lua_getstack(self.state, 1, &dbg) != 0 and
            lua_getinfo(self.state, "nSl", &dbg) != 0)
        {
            const msg = sds.catPrintf(
                allocator.impl,
                sds.empty(allocator.impl),
                "{s}: {}: {s}",
                .{
                    dbg.source,
                    dbg.currentline,
                    err,
                },
            );
            defer sds.free(allocator.impl, msg);
            lua_pushlstring(self.state, msg, sds.getLen(msg));
        } else {
            lua_pushlstring(self.state, err.ptr, err.len);
        }
        lua_settable(self.state, -3);
    }

    /// In case the error set into the Lua stack by pushError() was generated
    /// by the non-error-trapping version of redis.pcall(), which is redis.call(),
    /// this function will raise the Lua error so that the execution of the
    /// script will be halted.
    fn raiseError(self: *Lua) c_int {
        lua_pushstring(self.state, "err");
        lua_gettable(self.state, -2);
        return lua_error(self.state);
    }

    fn reset(self: *Lua) void {
        self.deinit();
        self.init(false);
    }

    /// Release resources related to Lua scripting.
    pub fn deinit(self: *Lua) void {
        self.scripts.destroy();
        lua_close(self.state);
    }
};

/// Perform the SHA1 of the input string. We use this both for hashing script
/// bodies in order to obtain the Lua function name, and in the implementation
/// of redis.sha1().
///
/// 'digest' should point to a 40 bytes buffer: 40 for SHA1 converted into an
/// hexadecimal number.
fn sha1hex(digest: *[40]u8, script: []const u8) void {
    var hash: [20]u8 = undefined;
    std.crypto.hash.Sha1.hash(script, &hash, .{});
    @memcpy(digest, std.fmt.bytesToHex(&hash, .lower)[0..]);
}

extern fn luaopen_cjson(?*lua_State) c_int;
extern fn luaopen_struct(?*lua_State) c_int;
extern fn luaopen_cmsgpack(?*lua_State) c_int;
extern fn luaopen_bit(?*lua_State) c_int;
const luaopen_base = liblua.luaopen_base;
const luaopen_table = liblua.luaopen_table;
const luaopen_string = liblua.luaopen_string;
const luaopen_math = liblua.luaopen_math;
const luaopen_debug = liblua.luaopen_debug;

const LUA_TABLIBNAME = liblua.LUA_TABLIBNAME;
const LUA_STRLIBNAME = liblua.LUA_STRLIBNAME;
const LUA_MATHLIBNAME = liblua.LUA_MATHLIBNAME;
const LUA_DBLIBNAME = liblua.LUA_DBLIBNAME;

const LUA_MASKCOUNT = liblua.LUA_MASKCOUNT;
const LUA_MASKLINE = liblua.LUA_MASKLINE;
const LUA_GCSTEP = liblua.LUA_GCSTEP;

const LUA_TNUMBER = liblua.LUA_TNUMBER;
const LUA_TSTRING = liblua.LUA_TSTRING;
const LUA_TBOOLEAN = liblua.LUA_TBOOLEAN;
const LUA_TTABLE = liblua.LUA_TTABLE;
const LUA_TNIL = liblua.LUA_TNIL;

/// luac.luaL_argcheck() will occur compile error.
fn luaL_argcheck(
    l: ?*lua_State,
    cond: bool,
    arg: c_int,
    extramsg: [*c]const u8,
) void {
    if (cond) {
        return;
    }
    _ = luaL_argerror(l, arg, extramsg);
}
const lua_gettop = liblua.lua_gettop;
const lua_State = liblua.lua_State;
const lua_Integer = liblua.lua_Integer;
const lua_CFunction = liblua.lua_CFunction;
const lua_Debug = liblua.lua_Debug;
const lua_close = liblua.lua_close;
const lua_pop = liblua.lua_pop;
const lua_getglobal = liblua.lua_getglobal;
const lua_pushstring = liblua.lua_pushstring;
const lua_pushlstring = liblua.lua_pushlstring;
const lua_open = liblua.lua_open;
const lua_pushcfunction = liblua.lua_pushcfunction;
const lua_settable = liblua.lua_settable;
const lua_pushnumber = liblua.lua_pushnumber;
const luaL_argerror = liblua.luaL_argerror;
const luaL_error = liblua.luaL_error;
const lua_error = liblua.lua_error;
const lua_tolstring = liblua.lua_tolstring;
const luaL_checkinteger = liblua.luaL_checkinteger;
const lua_newtable = liblua.lua_newtable;
const lua_gettable = liblua.lua_gettable;
const lua_setglobal = liblua.lua_setglobal;
const luaL_loadbuffer = liblua.luaL_loadbuffer;
const lua_pcall = liblua.lua_pcall;
const lua_call = liblua.lua_call;
const lua_pushnil = liblua.lua_pushnil;
const lua_isnil = liblua.lua_isnil;
const lua_sethook = liblua.lua_sethook;
const lua_gc = liblua.lua_gc;
const lua_rawseti = liblua.lua_rawseti;
const lua_isnumber = liblua.lua_isnumber;
const lua_tonumber = liblua.lua_tonumber;
const lua_getstack = liblua.lua_getstack;
const lua_getinfo = liblua.lua_getinfo;
const lua_type = liblua.lua_type;
const lua_checkstack = liblua.lua_checkstack;
const lua_pushvalue = liblua.lua_pushvalue;
const lua_toboolean = liblua.lua_toboolean;
const lua_pushboolean = liblua.lua_pushboolean;

const std = @import("std");
const Server = @import("Server.zig");
const allocator = @import("allocator.zig");
const oom = allocator.oom;
const networking = @import("networking.zig");
const Client = networking.Client;
const dict = @import("dict.zig");
const sds = @import("sds.zig");
const Object = @import("Object.zig");
const hasher = @import("hasher.zig");
const liblua = @cImport({
    @cInclude("lualib.h");
    @cInclude("lua.h");
    @cInclude("lauxlib.h");
});
const assert = std.debug.assert;
const server = &Server.instance;
const db = @import("db.zig");
const logging = @import("logging.zig");
const eqlCase = std.ascii.eqlIgnoreCase;
const scripting = @This();
const util = @import("util.zig");
const memlib = @import("mem.zig");
const memcpy = memlib.memcpy;
